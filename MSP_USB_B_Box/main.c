// The following section defines the HID Usage codes for each defined key on the
// keyboard.
#define usbUsageReserved            0x00
#define usbUsageErrorRollOver       0x01
#define usbUsagePOSTFail            0x02
#define usbUsageErrorUndefined      0x03
#define usbUsageA                   0x04
#define usbUsageB                   0x05
#define usbUsageC                   0x06
#define usbUsageD                   0x07
#define usbUsageE                   0x08
#define usbUsageF                   0x09
#define usbUsageG                   0x0A
#define usbUsageH                   0x0B
#define usbUsageI                   0x0C
#define usbUsageJ                   0x0D
#define usbUsageK                   0x0E
#define usbUsageL                   0x0F
#define usbUsageM                   0x10
#define usbUsageN                   0x11
#define usbUsageO                   0x12
#define usbUsageP                   0x13
#define usbUsageQ                   0x14
#define usbUsageR                   0x15
#define usbUsageS                   0x16
#define usbUsageT                   0x17
#define usbUsageU                   0x18
#define usbUsageV                   0x19
#define usbUsageW                   0x1A
#define usbUsageX                   0x1B
#define usbUsageY                   0x1C
#define usbUsageZ                   0x1D
#define usbUsage1                   0x1E
#define usbUsage2                   0x1F
#define usbUsage3                   0x20
#define usbUsage4                   0x21
#define usbUsage5                   0x22
#define usbUsage6                   0x23
#define usbUsage7                   0x24
#define usbUsage8                   0x25
#define usbUsage9                   0x26
#define usbUsage0                   0x27
#define usbUsageEnter               0x28
#define usbUsageEscape              0x29
#define usbUsageBackspace           0x2A
#define usbUsageTab                 0x2B
#define usbUsageSpacebar            0x2C
#define usbUsageMinus               0x2D
#define usbUsageEqual               0x2E
#define usbUsageLeftBracket         0x2F
#define usbUsageRightBracket        0x30
#define usbUsageBackslash           0x31
#define usbUsageVerticalBar         0x32
#define usbUsageSemicolon           0x33
#define usbUsageApostrophe          0x34
#define usbUsageTilde               0x35
#define usbUsageComma               0x36
#define usbUsagePeriod              0x37
#define usbUsageSlash               0x38
#define usbUsageCapsLock            0x39
#define usbUsageF1                  0x3A
#define usbUsageF2                  0x3B
#define usbUsageF3                  0x3C
#define usbUsageF4                  0x3D
#define usbUsageF5                  0x3E
#define usbUsageF6                  0x3F
#define usbUsageF7                  0x40
#define usbUsageF8                  0x41
#define usbUsageF9                  0x42
#define usbUsageF10                 0x43
#define usbUsageF11                 0x44
#define usbUsageF12                 0x45
#define usbUsagePrintScreen         0x46
#define usbUsageScrollLock          0x47
#define usbUsagePause               0x48
#define usbUsageInsert              0x49
#define usbUsageHome                0x4A
#define usbUsagePageUp              0x4B
#define usbUsageDeleteForward       0x4C
#define usbUsageEnd                 0x4D
#define usbUsagePageDown            0x4E
#define usbUsageRightArrow          0x4F
#define usbUsageLeftArrow           0x50
#define usbUsageDownArrow           0x51
#define usbUsageUpArrow             0x52
#define usbUsageKeypadNumlock       0x53
#define usbUsageKeypadSlash         0x54
#define usbUsageKeypadAsterisk      0x55
#define usbUsageKeypadMinus         0x56
#define usbUsageKeypadPlus          0x57
#define usbUsageKeypadEnter         0x58
#define usbUsageKeypad1             0x59
#define usbUsageKeypad2             0x5A
#define usbUsageKeypad3             0x5B
#define usbUsageKeypad4             0x5C
#define usbUsageKeypad5             0x5D
#define usbUsageKeypad6             0x5E
#define usbUsageKeypad7             0x5F
#define usbUsageKeypad8             0x60
#define usbUsageKeypad9             0x61
#define usbUsageKeypad0             0x62
#define usbUsageKeypadPeriod        0x63
#define usbUsageNonUsBackslash      0x64
#define usbUsageWindowsKey          0x65
#define usbUsagePower               0x66
#define usbUsageKeypadEqual         0x67
#define usbUsageF13                 0x68
#define usbUsageF14                 0x69
#define usbUsageF15                 0x6A
#define usbUsageF16                 0x6B
#define usbUsageF17                 0x6C
#define usbUsageF18                 0x6D
#define usbUsageF19                 0x6E
#define usbUsageF20                 0x6F
#define usbUsageF21                 0x70
#define usbUsageF22                 0x71
#define usbUsageF23                 0x72
#define usbUsageF24                 0x73
#define usbUsageExecute             0x74
#define usbUsageHelp                0x75
#define usbUsageMenu                0x76
#define usbUsageSelect              0x77
#define usbUsageStop                0x78
#define usbUsageAgain               0x79
#define usbUsageUndo                0x7A
#define usbUsageCut                 0x7B
#define usbUsageCopy                0x7C
#define usbUsagePaste               0x7D
#define usbUsageFind                0x7E
#define usbUsageMute                0x7F
#define usbUsageVolumeUp            0x80
#define usbUsageVolumneDown         0x81
#define usbUsageLockingCapsLock     0x82
#define usbUsageLockingNumLock      0x83
#define usbUsageLockingScrollLock   0x84
#define usbUsageKeypadComma         0x85
#define usbUsageAS400KeypadEqual    0x86
#define usbUsageInternational1      0x87
#define usbUsageInternational2      0x88
#define usbUsageInternational3      0x89
#define usbUsageInternational4      0x8A
#define usbUsageInternational5      0x8B
#define usbUsageInternational6      0x8C
#define usbUsageInternational7      0x8D
#define usbUsageInternational8      0x8E
#define usbUsageInternational9      0x8F
#define usbUsageLang1               0x90
#define usbUsageLang2               0x91
#define usbUsageLang3               0x92
#define usbUsageLang4               0x93
#define usbUsageLang5               0x94
#define usbUsageLang6               0x95
#define usbUsageLang7               0x96
#define usbUsageLang8               0x97
#define usbUsageLang9               0x98
#define usbUsageAlternateErase      0x99
#define usbUsageSysReq              0x9A
#define usbUsageCancel              0x9B
#define usbUsageClear               0x9C
#define usbUsagePrior               0x9D
#define usbUsageReturn              0x9E
#define usbUsageSeparator           0x9F
#define usbUsageOut                 0xA0
#define usbUsageOper                0xA1
#define usbUsageClearAgain          0xA2
#define usbUsageCrSelProps          0xA3
#define usbUsageExSel               0xA4
#define usbUsageLeftControl         0xE0
#define usbUsageLeftShift           0xE1
#define usbUsageLeftAlt             0xE2
#define usbUsageLeftGUI             0xE3
#define usbUsageRightControl        0xE4
#define usbUsageRightShift          0xE5
#define usbUsageRightAlt            0xE6
#define usbUsageRightGUI            0xE7

#define NUMBER_OF_KEYS              14

#include "USB_API/USB_Common/device.h"
#include "USB_API/USB_Common/types.h"          // Basic Type declarations
#include "USB_config/descriptors.h"
#include "USB_API/USB_Common/usb.h"        // USB-specific functions
#include "F5xx_F6xx_Core_Lib/HAL_UCS.h"
#include "F5xx_F6xx_Core_Lib/HAL_PMM.h"

#ifdef _CDC_
    #include "USB_API/USB_CDC_API/UsbCdc.h"
#endif
#ifdef _HID_
    #include "USB_API/USB_HID_API/UsbHid.h"
#endif

#include <intrinsics.h>
#include <string.h>
#include "usbConstructs.h"

VOID Init_Ports(VOID);
VOID Init_Clock(VOID);
VOID USB_handler(VOID);

BYTE keys[NUMBER_OF_KEYS] = {usbUsageA,
                             usbUsageB,
                             usbUsageC,
                             usbUsageD,
                             usbUsageE,
                             usbUsageF,
                             usbUsageG,
                             usbUsageH,
                             usbUsageI,
                             usbUsageJ,
                             usbUsageK,
                             usbUsageL,
                             usbUsageM,
                             usbUsageN};
BYTE send_reports[3] = {usbUsageReserved, usbUsageReserved, usbUsageReserved};
BYTE button_pressed = FALSE;

VOID main(VOID) {
    WDTCTL = WDTPW + WDTHOLD;	    // Stop watchdog timer
    Init_Ports();                   // initialize device
    USB_init();                     // init USB

    // Enable various USB event handling routines
    USB_setEnabledEvents(kUSB_VbusOnEvent+kUSB_VbusOffEvent+kUSB_UsbSuspendEvent+kUSB_UsbResumeEvent);
    
    // See if we're already attached physically to USB, and if so, connect to it
    // Normally applications don't invoke the event handlers, but this is an exception.  
    if (USB_connectionInfo() & kUSB_vbusPresent)
      USB_handleVbusOnEvent();

    while(1) {

    
    }
}

//----------------------------------------------------------------------------
VOID USB_Handler(unsigned char BUTTON){
    // Check the USB state and directly main loop accordingly
    switch(USB_connectionState()) {
        case ST_USB_DISCONNECTED:
            __bis_SR_register(LPM3_bits + GIE);                 // Enter LPM3 w/ interrupts enabled
            _NOP();                                              // For Debugger
            break;

        case ST_USB_CONNECTED_NO_ENUM:
            break;

        case ST_ENUM_ACTIVE:
            __bis_SR_register(LPM0_bits + GIE);                  // Enter LPM0 (can't do LPM3 when active)
            _NOP();                                              // For Debugger

            if(button_pressed) {
                send_reports[2] = keys[BUTTON];
                USBHID_sendReport((void *) &send_reports, 0);
                BYTE i;
                for (i = 2; i > 0; i--){
                    send_reports[i] = usbUsageReserved;
                }
                USBHID_sendReport((void *) &send_reports, 0);

                button_pressed = FALSE;
            }
            break;

        case ST_ENUM_SUSPENDED:
            P1OUT &= ~BIT0;                                 // When suspended, turn off LED
            __bis_SR_register(LPM3_bits + GIE);             // Enter LPM3 w/ interrupts
            break;

        case ST_ENUM_IN_PROGRESS:
            break;

        case ST_NOENUM_SUSPENDED:
            __bis_SR_register(LPM3_bits + GIE);
            break;

        case ST_ERROR:
            _NOP();
            break;

            default:;
    }
}

/*----------------------------------------------------------------------------+
| System Initialization Routines                                              |
+----------------------------------------------------------------------------*/

// Initializes the clocks.  Starts the DCO at USB_MCLK_FREQ (the CPU freq set with the Desc 
// Tool), using the REFO as the FLL reference.  Configures the high-freq crystal, but 
// doesn't start it yet.  Takes some special actions for F563x/663x.  
VOID Init_Clock(VOID) {
    #if defined (__MSP430F563x_F663x)
      while(BAKCTL & LOCKIO)                  // Unlock XT1 pins for operation
      BAKCTL &= ~(LOCKIO);                    // Enable XT1 pins
      // Workaround for USB7 chip errata
      UCSCTL6 &= ~XT1OFF;
    #endif
    if (USB_PLL_XT == 2)
    {
        // Enable XT2 pins
        #if defined (__MSP430F552x) || defined (__MSP430F550x)
          P5SEL |= 0x0C;                      
        #elif defined (__MSP430F563x_F663x)
          P7SEL |= 0x0C;
        #endif
          
        // Use the REFO oscillator as the FLL reference, and also for ACLK
        UCSCTL3 = (UCSCTL3 & ~(SELREF_7)) | (SELREF__REFOCLK);
        UCSCTL4 = (UCSCTL4 & ~(SELA_7)) | (SELA__REFOCLK);
        
        // Start the FLL, which will drive MCLK (not the crystal)
        Init_FLL(USB_MCLK_FREQ/1000, USB_MCLK_FREQ/32768);  
    }
    else
    {
        // Enable XT1 pins
        #if defined (__MSP430F552x) || defined (__MSP430F550x)
          P5SEL |= 0x10;                    
        #endif 
        
        // Use the REFO oscillator as the FLL reference, and also for ACLK
        UCSCTL3 = SELREF__REFOCLK;             
        UCSCTL4 = (UCSCTL4 & ~(SELA_7)) | (SELA__REFOCLK); 
        
        // Start the FLL, which will drive MCLK (not the crystal)
        Init_FLL(USB_MCLK_FREQ/1000, USB_MCLK_FREQ/32768); // set FLL (DCOCLK)
    }
}

//----------------------------------------------------------------------------

VOID Init_Ports(VOID) {
    // Initialization of ports all unused pins as outputs with low-level

    // set all ports  to low on all pins
    PAOUT   =   0x0000;
    PASEL   =   0x0000;
    PADIR   =   0xFFFF;

    PBOUT   =   0x0000;
    PBSEL   =   0x0000;
    PBDIR   =   0xFFFF;

    PCOUT   =   0x0000;
    PCSEL   =   0x0000;
    PCDIR   =   0xFFFF;

	#ifndef __MSP430F550x
    PDOUT   =   0x0000;      //	If using a device other than: 
    PDSEL   =   0x0000;	     //	F5510, F5529, F5638, or F6638 
    PDDIR   =   0xFFFF;      //	you may need to comment out these lines 
    #endif 
    
    #if defined (__MSP430F563x_F663x)
    P9OUT   =   0x00;
    P9SEL   =   0x00;
    P9DIR   =   0xFF;
    #endif

    PJDIR   =   0xFFFF;
    PJOUT   =   0x0000;
}


//----------------------------------------------------------------------------

VOID Init_StartUp(VOID) {
    __disable_interrupt();               // Disable global interrupts
    
    Init_Ports();                        // Init ports (do first ports because clocks do change ports)
    SetVCore(3);                         // USB core requires the VCore set to 1.8 volt, independ of CPU clock frequency
    Init_Clock();

    __enable_interrupt();                // enable global interrupts
}


#pragma vector = UNMI_VECTOR
__interrupt VOID UNMI_ISR(VOID) {
    switch (__even_in_range(SYSUNIV, SYSUNIV_BUSIFG)) {
    case SYSUNIV_NONE:
      __no_operation();
      break;
    case SYSUNIV_NMIIFG:
      __no_operation();
      break;
    case SYSUNIV_OFIFG:
      UCSCTL7 &= ~(DCOFFG+0+0+0); // Clear OSC flaut Flags fault flags
      SFRIFG1 &= ~OFIFG;                                // Clear OFIFG fault flag
      break;
    case SYSUNIV_ACCVIFG:
      __no_operation();
      break;
    case SYSUNIV_BUSIFG:

      // If bus error occured - the cleaning of flag and re-initializing of USB is required.
      SYSBERRIV = 0;            // clear bus error flag
      USB_disable();            // Disable
    }
}
